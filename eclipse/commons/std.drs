/*
Standard library
*/

function write(x) {
	#{
		load_arg 0;
		send "toString" 0;
		sp_write;
	}
}

function writeln(x) {
	write("" + x + "\n");
}

function readln() {
	#{
		sp_next_line;
		ret 1;
	}
}
/*
// Implicit inheritance based on protocol?
Any = extend([]);
Any.clone = function() {
	#{
		load_arg 0;
		sp_clone;
		ret 1;
	}
}
*/

/*
// Inlines? How?
Any.callFunc = inline(args, function) {
	// stack: function, args
	#{
		sp_call;
	}
}
*/

Any.clone = function() {
	#{
		load_this;
		sp_clone;
		ret 1;
	}
};

/*
What about associating each definition with a particular number of arguments?

E.g. binary and unary version of +
function +(other) {
	...
}
function +() {
	...
}

Then how to solve the following case? How many arguments?

var x = function(other) {
	...
};
this.+ = x;

Perhaps:

this.+ = x; // No arguments
this.+() = x; // No arguments
this.+(:) = x; // One argument
this.+(::) = x; // Two arguments
*/

String.+ = function(other) {
	#{
		load_this;
		load_arg 0;
		send "toString" 0;
		sp_string_concat;
		ret 1;
	}
};
String.toString = function() {
	return this;
};
String.== = function(other) {
	#{
		load_this;
		load_arg 0;
		sp_string_equal;
		ret 1;
	}
};
String.!= = function(other) {
	#{
		load_this;
		load_arg 0;
		sp_string_equal;
		sp_not;
		ret 1;
	}
};

Integer.+ = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_add;
		ret 1;
	}
};
Integer.- = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_sub;
		ret 1;
	}
};
Integer.* = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_mult;
		ret 1;
	}
};
Integer./ = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_div;
		ret 1;
	}
};
Integer.% = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_rem;
		ret 1;
	}
};
Integer.toString = function() {
	#{
		load_this;
		sp_int_to_string;
		ret 1;
	}
};

/*
Add definition of greater/less operator here for Integer prototype
*/

Integer.> = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_greater;
		ret 1;
	}
};
Integer.>= = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_greater;
		if_false test_equals;
		load_true;
		ret 1;
		
		test_equals:
		load_this;
		load_arg 0;
		sp_int_equal;
		ret 1;
	}
};
Integer.< = function(other) {
	// Should do double dispatching
	#{
		load_this;
		load_arg 0;
		sp_int_less;
		ret 1;
	}
};
Integer.<= = function(other) {
	#{
		load_this;
		load_arg 0;
		sp_int_less;
		if_false test_equals;
		load_true;
		ret 1;
		
		test_equals:
		load_this;
		load_arg 0;
		sp_int_equal;
		ret 1;
	}
};
Integer.== = function(other) {
	#{
		load_this;
		load_arg 0;
		sp_int_equal;
		ret 1;
	}
};
Integer.!= = function(other) {
	#{
		load_this;
		load_arg 0;
		sp_int_equal;
		sp_not;
		ret 1;
	}
};
