/*
Standard library
*/

function write(x) {
	§sp_write(x.toString());
}

function writeln(x) {
	write("" + x + "\n");
}

function readln() {
	return §sp_next_line();
}
/*
// Implicit inheritance based on protocol?
Any = extend([]);
Any.clone = function() {
	#{
		load_arg 0;
		sp_clone;
		ret 1;
	}
}
*/

/*
// Inlines? How?
Any.callFunc = inline(args, function) {
	// stack: function, args
	#{
		sp_call;
	}
}
*/

Any.clone = function() {
	return §sp_clone(this);
};
Any.== = function(other) {
	return other.equalsAny(this);
};
Any.equalsAny = function(lhs) {
	return §sp_ref_equal(lhs, this);
};
Any.equalsInt = function(lhs) {
	return false;
};
Any.equalsString = function(lhs) {
	return false;
};
Any.!= = function(other) {
	return !(this == other);
};

/*
What about associating each definition with a particular number of arguments?

E.g. binary and unary version of +
function +(other) {
	...
}
function +() {
	...
}

Then how to solve the following case? How many arguments?

var x = function(other) {
	...
};
this.+ = x;

Perhaps:

this.+ = x; // No arguments
this.+() = x; // No arguments
this.+(:) = x; // One argument
this.+(::) = x; // Two arguments
*/

String.+ = function(other) {
	return §sp_string_concat(this, other.toString());
};
String.toString = function() {
	return this;
};
String.== = function(other) {
	return other.equalsString(this);
};
String.equalsString = function(lhs) {
	return §sp_string_equal(lhs, this);
};

Integer.+ = function(other) {
	// Should do double dispatching
	return §sp_int_add(this, other);
};
Integer.- = function(other) {
	// Should do double dispatching
	return §sp_int_sub(this, other);
};
Integer.* = function(other) {
	// Should do double dispatching
	return §sp_int_mult(this, other);
};
Integer./ = function(other) {
	// Should do double dispatching
	return §sp_int_div(this, other);
};
Integer.% = function(other) {
	// Should do double dispatching
	return §sp_int_rem(this, other);
};
Integer.toString = function() {
	return §sp_int_to_string(this);
};

/*
Add definition of greater/less operator here for Integer prototype
*/

Integer.> = function(other) {
	// Should do double dispatching
	return §sp_int_greater(this, other);
};
Integer.>= = function(other) {
	// Should do double dispatching
	if(§sp_int_greater(this, other))
		return true;
	return §sp_int_equal(this, other);
};
Integer.< = function(other) {
	// Should do double dispatching
	return §sp_int_less(this, other);
};
Integer.<= = function(other) {
	// Should do double dispatching
	if(§sp_int_less(this, other))
		return true;
	return §sp_int_equal(this, other);
};
Integer.== = function(other) {
	return other.equalsInt(this);
};
Integer.equalsInt = function(lhs) {
	return §sp_int_equal(lhs, this);
};

Frame.sender = function() {
	return §sp_frame_sender(this);
};
Frame.setSender = function(newSender) {
	return §sp_frame_set_sender(this, newSender);
};
Frame.resume = function(x) {
	return §sp_frame_resume(this, x);
};

Closure.call = function() {
	return §call_closure(this);
};