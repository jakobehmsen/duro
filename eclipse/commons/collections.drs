/*
Collections library
*/

Iterable = #[]
Iterable@each => (
	var iterator = iterator()
	while: not: iterator.atEnd,
		\block.call: iterator.next
)
Iterable@where => |predicate| Generatable.on: {|generator|
	each: {
		if: predicate.call: \next, generator.put: \next
	}
}
Iterable@map => |block| Generatable.on: {|generator|
	each: {
		var mapped = block.call: \next
		generator.put: mapped
	}
}

Generator = #[
	on => |block| (
		var generator = #[
			current = null
			producer = null
			mover = null
			gotNext = false
			moveNext => (
				gotNext = false
				mover = frame
				producer.resume: null
			)
			close => (
				gotNext = false
				mover.resume: null
			)
			atEnd => not: gotNext
			put => (
				current = \item
				gotNext = true
				producer = frame.sender
				mover.resume: null
			)
			next => (
				var previous = current
				moveNext()
				return: previous
			)
		]
		
		generator@mover = frame
		{
			block.call: generator
			generator.close
		}.call

		return: generator
	)
]

Generatable = #[
	on => #[
		prototype ^= Iterable
		block = \block
		iterator => Generator.on: block
	]
]

newArray => newArray: \length

Array@prototype ^= Iterable
Array@[] => arraySet: this, \index, \value
Array@[] => arrayGet: this, \index
Array@length => arrayLength: this
Array@iterator => Generator.on: {
	var i = 0
	while: i < length(), (
		var item = this[i]
		\generator.put: item
		i = i + 1
	)
}



Integer@to => |end| Generatable.on: {
	var i = this
	while: i < end, (
		\generator.put: i
		i = i + 1
	)
}
Integer@through => to: \end + 1

/*
// Implicit inheritance based on protocol?

Iterable = extend(["iterable"]);

Iterable.where = function(predicate) {
	for(var x in this) {
		if(predicate(x))
			yield x;
	}
}
*/

List = #[
	prototype ^= Iterable
	items = newArray: 12
	capacity = 12
	size = 0
	add => (
		items[size] = \item
		size = size + 1
	)
	iterator => Generator.on: {
		var i = 0
		while: i < size, (
			var item = items[i]
			\generator.put: item
			i = i + 1
		)
	}
	[] => items[\index] = \value
	[] => items[\index]
]
